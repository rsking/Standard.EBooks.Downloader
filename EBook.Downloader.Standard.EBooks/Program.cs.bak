// -S----------------------------------------------------------------------
// <copyright file="Program.cs" company="RossKing">
// Copyright (c) RossKing. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

#pragma warning disable SA1200 // Using directives should be placed correctly
using System;
using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Hosting;
using System.CommandLine.Invocation;
using System.CommandLine.Parsing;
using System.Linq;
using System.Threading.Tasks;
using EBook.Downloader.Common;
using EBook.Downloader.Standard.EBooks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Serilog;
#pragma warning restore SA1200 // Using directives should be placed correctly

const int SentinelRetryCount = 30;

const int SentinelRetryWait = 100;

const int MaxTimeOffset = 180;

const string AtomUrl = "https://standardebooks.org/opds/all";

var builder = new CommandLineBuilder(new RootCommand("Standard EBook Downloder") { Handler = CommandHandler.Create<IHost, System.IO.DirectoryInfo, System.IO.DirectoryInfo, bool, bool, int>(Process) })
    .AddArgument(new Argument<System.IO.DirectoryInfo>("CALIBRE-LIBRARY-PATH") { Description = "The path to the directory containing the calibre library", Arity = ArgumentArity.ExactlyOne }.ExistingOnly())
    .AddOption(new Option<System.IO.DirectoryInfo>(new[] { "-o", "--output-path" }, "The output path") { Argument = new Argument<System.IO.DirectoryInfo>("PATH", () => new System.IO.DirectoryInfo(Environment.CurrentDirectory)) { Arity = ArgumentArity.ExactlyOne } }.ExistingOnly())
    .AddOption(new Option<bool>(new[] { "-c", "--check-metadata" }, "Whether to check the metadata"))
    .AddOption(new Option<bool>(new[] { "-r", "--resync" }, "Forget the last saved state, perform a full sync"))
    .AddOption(new Option<int>(new[] { "-m", "--max-time-offset" }, () => MaxTimeOffset, "The maximum time offset"))
    .UseHost(
        Host.CreateDefaultBuilder,
        configureHost =>
        {
            configureHost
                .UseSerilog((_, loggerConfiguration) => loggerConfiguration
                    .WriteTo
                    .Console(formatProvider: System.Globalization.CultureInfo.CurrentCulture, outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] <{ThreadId:00}> {Message:lj}{NewLine}{Exception}")
                    .Filter.ByExcluding(Serilog.Filters.Matching.FromSource(typeof(System.Net.Http.HttpClient).FullName ?? string.Empty))
                    .Enrich.WithThreadId())
                .ConfigureServices((_, services) => services
                    .AddHttpClient(string.Empty)
                    .ConfigureHttpClient(c => c.Timeout = TimeSpan.FromMinutes(30))
                    .Services
                    .AddHttpClient("header")
                    .ConfigurePrimaryHttpMessageHandler(() => new System.Net.Http.HttpClientHandler { AllowAutoRedirect = false, AutomaticDecompression = System.Net.DecompressionMethods.None }));
        });

return await builder.Build().InvokeAsync(args.Select(Environment.ExpandEnvironmentVariables).ToArray()).ConfigureAwait(false);

static async Task Process(
    IHost host,
    System.IO.DirectoryInfo calibreLibraryPath,
    System.IO.DirectoryInfo outputPath,
    bool checkMetadata = false,
    bool resync = false,
    int maxTimeOffset = MaxTimeOffset)
{
    var programLogger = host.Services.GetRequiredService<ILogger<EpubInfo>>();
    AppDomain.CurrentDomain.UnhandledException += (sender, e) =>
    {
        switch (e.ExceptionObject)
        {
            case Exception exception:
                programLogger.LogError(exception, exception.Message);
                break;
            case null:
                programLogger.LogError("Unhandled Exception");
                break;
            default:
                programLogger.LogError(e.ExceptionObject.ToString());
                break;
        }
    };

    var atom = new System.ServiceModel.Syndication.Atom10FeedFormatter();
    using (var xml = System.Xml.XmlReader.Create(AtomUrl))
    {
        atom.ReadFrom(xml);
    }

    var sentinelPath = System.IO.Path.Combine(calibreLibraryPath.FullName, ".sentinel");

    if (!System.IO.File.Exists(sentinelPath))
    {
        await System.IO.File.WriteAllBytesAsync(sentinelPath, Array.Empty<byte>()).ConfigureAwait(false);
        System.IO.File.SetLastWriteTimeUtc(sentinelPath, DateTime.MinValue.ToUniversalTime());
    }

    var sentinelDateTime = resync
        ? DateTime.MinValue.ToUniversalTime()
        : System.IO.File.GetLastWriteTimeUtc(sentinelPath);

    var sentinelLock = new object();
    var httpClientFactory = host.Services.GetRequiredService<System.Net.Http.IHttpClientFactory>();
    var atomUri = new Uri(AtomUrl);
    using var calibreLibrary = new CalibreLibrary(calibreLibraryPath.FullName, host.Services.GetRequiredService<ILogger<CalibreLibrary>>());
    foreach (var item in atom.Feed.Items
        .Where(item => item.LastUpdatedTime > sentinelDateTime)
        .OrderBy(item => item.LastUpdatedTime)
        .AsParallel())
    {
        // get the name, etc
        var name = string.Join(" & ", item.Authors.Select(author => author.Name));
        programLogger.LogInformation("Processing book {Title} - {Name}", item.Title.Text, name);
        using var bookScope = programLogger.BeginScope("{Title} - {Name}", item.Title.Text, name);
        foreach (var uri in item.Links
            .Where(IsValidEBook)
            .Select(AbsoluteUri))
        {
            // get the date time
            var extension = uri.GetExtension();
            var kepub = string.Equals(extension, ".kepub", StringComparison.InvariantCultureIgnoreCase);
            var book = await calibreLibrary.GetBookByIdentifierAndExtensionAsync(item.Id, "url", extension).ConfigureAwait(false);
            var lastWriteTimeUtc = DateTime.MinValue;
            if (book is not null)
            {
                var filePath = book.GetFullPath(calibreLibrary.Path, extension);
                if (System.IO.File.Exists(filePath))
                {
                    lastWriteTimeUtc = System.IO.File.GetLastWriteTimeUtc(filePath);

                    // Only update the description/last modified from the EPUB
                    if (!kepub)
                    {
                        // see if we should update the date time
                        if (checkMetadata)
                        {
                            var epub = EpubInfo.Parse(filePath, true);
                            await calibreLibrary.UpdateLastModifiedDescriptionAndSeriesAsync(book, lastWriteTimeUtc, epub.LongDescription, epub.SeriesName, (float)epub.SeriesIndex, maxTimeOffset).ConfigureAwait(false);
                        }
                        else
                        {
                            await calibreLibrary.UpdateLastModified(book, lastWriteTimeUtc, maxTimeOffset).ConfigureAwait(false);
                        }
                    }
                }
            }
            else
            {
                programLogger.LogInformation("{Title} - {Name} does not exist in Calibre", item.Title.Text, name);
            }

            var actualUri = await uri.ShouldDownloadAsync(lastWriteTimeUtc, httpClientFactory, url =>
            {
                var uriString = url.ToString();
                var baseUri = uriString.Substring(0, uriString.LastIndexOf("/", StringComparison.OrdinalIgnoreCase) + 1);

                var split = GetFileNameWithoutExtension(uriString).Split('_');
                var number = Math.Max(split.Length - 1, 2);
                split = split[..number];
                var fileName = string.Join('_', split.Take(number));
                return new Uri(baseUri + fileName + GetExtension(uriString));

                static string GetFileNameWithoutExtension(string path)
                {
                    var fileName = GetFileName(path);
                    return fileName.Substring(0, fileName.IndexOf('.', StringComparison.OrdinalIgnoreCase));
                }

                static string GetExtension(string path)
                {
                    var fileName = GetFileName(path);
                    return fileName[fileName.IndexOf('.', StringComparison.OrdinalIgnoreCase)..];
                }

                static string GetFileName(string path)
                {
                    return path[(path.LastIndexOf('/') + 1)..];
                }
            }).ConfigureAwait(false);

            if (actualUri is null)
            {
                continue;
            }

            // download this
            var path = await DownloadBookAsync(actualUri, outputPath.FullName, programLogger, httpClientFactory).ConfigureAwait(false);
            if (path is null)
            {
                continue;
            }

            var epubInfo = EpubInfo.Parse(path, !kepub);
            if (await calibreLibrary.AddOrUpdateAsync(epubInfo, maxTimeOffset).ConfigureAwait(false))
            {
                programLogger.LogDebug("Deleting, {0} - {1} - {2}", epubInfo.Title, string.Join("; ", epubInfo.Authors), epubInfo.Extension);
                System.IO.File.Delete(epubInfo.Path);
            }
        }

        lock (sentinelLock)
        {
            // update the sentinel time
            var i = 0;
            while (true)
            {
                i++;
                try
                {
                    System.IO.File.SetLastWriteTimeUtc(sentinelPath, item.LastUpdatedTime.UtcDateTime);
                    break;
                }
                catch (System.IO.IOException) when (i != SentinelRetryCount)
                {
                }

                System.Threading.Thread.Sleep(SentinelRetryWait);
            }
        }
    }

    static bool IsValidEBook(System.ServiceModel.Syndication.SyndicationLink link)
    {
        return IsEPub(link) || IsKobo(link);

        static bool IsEPub(System.ServiceModel.Syndication.SyndicationLink link)
        {
            return string.Equals(link.MediaType, "application/epub+zip", StringComparison.Ordinal)
                && (link.Uri.OriginalString.EndsWith("epub3", StringComparison.InvariantCultureIgnoreCase) || System.IO.Path.GetFileNameWithoutExtension(link.Uri.OriginalString).EndsWith("_advanced", System.StringComparison.InvariantCultureIgnoreCase));
        }

        static bool IsKobo(System.ServiceModel.Syndication.SyndicationLink link)
        {
            return string.Equals(link.MediaType, "application/kepub+zip", StringComparison.Ordinal);
        }
    }

    Uri AbsoluteUri(System.ServiceModel.Syndication.SyndicationLink link)
    {
        return link.Uri.IsAbsoluteUri ? link.Uri : new Uri(atomUri, link.Uri.OriginalString);
    }

    static async Task<string?> DownloadBookAsync(Uri uri, string path, Microsoft.Extensions.Logging.ILogger logger, System.Net.Http.IHttpClientFactory httpClientFactory)
    {
        // create the file name
        var fileName = uri.GetFileName();
        var fullPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(path, fileName));
        if (!System.IO.File.Exists(fullPath))
        {
            logger.LogInformation("Downloading book {0}", fileName);
            try
            {
                await uri.DownloadAsFileAsync(fullPath, false, httpClientFactory).ConfigureAwait(false);
            }
            catch (System.Net.Http.HttpRequestException ex)
            {
                logger.LogError(ex, ex.Message);
                return default;
            }
        }

        return fullPath;
    }
}